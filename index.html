<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flickr Signage Slideshow â€” Last 7 Days</title>
  <meta name="description" content="Auto-updating Flickr slideshow for digital signage. Shows multiple photos per slide, actual size, techy animations." />
  <style>
    :root {
      --bg: #000;
      --fg: #eafcff;
      --accent: #00e5ff;
      --accent-2: #7cf9ff;
      --gap: 16px;
      --slide-duration: 12s;
      --row-target: 320px;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow: hidden;
    }

    .bg-tech {
      position: fixed;
      inset: 0;
      background:
        radial-gradient(circle at 50% 0%, rgba(0,229,255,0.08), transparent 40%),
        radial-gradient(circle at 0% 100%, rgba(0,229,255,0.06), transparent 40%),
        linear-gradient(90deg, rgba(0,229,255,0.05) 1px, transparent 1px) 0 0 / 40px 40px,
        linear-gradient(0deg, rgba(0,229,255,0.05) 1px, transparent 1px) 0 0 / 40px 40px,
        radial-gradient(circle at 100% 50%, rgba(124,249,255,0.06), transparent 35%);
      pointer-events: none;
      filter: saturate(120%);
      animation: bgFloat 18s ease-in-out infinite alternate;
    }
    @keyframes bgFloat {
      0% { transform: translateY(-1%) scale(1.02); opacity: 0.9; }
      100% { transform: translateY(1%) scale(1.05); opacity: 1; }
    }

    .scanlines {
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(0,0,0,0.12),
        rgba(0,0,0,0.12) 1px,
        transparent 2px,
        transparent 4px
      );
      mix-blend-mode: multiply;
      pointer-events: none;
      opacity: 0.35;
      animation: flicker 6s linear infinite;
    }
    @keyframes flicker {
      0%, 100% { opacity: 0.35; }
      40% { opacity: 0.28; }
      50% { opacity: 0.4; }
      60% { opacity: 0.3; }
    }

    .stage {
      position: fixed;
      inset: 0;
      padding: 24px;
      display: grid;
      place-items: center;
    }
    .slide {
      position: absolute;
      inset: 24px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: var(--gap);
      opacity: 0;
      transform: perspective(1200px) rotateY(-8deg) scale(0.985) translateY(10px);
      transition: opacity 900ms ease, transform 900ms ease;
    }
    .slide.active {
      opacity: 1;
      transform: perspective(1200px) rotateY(0deg) scale(1) translateY(0);
    }

    .row {
      width: 100%;
      display: flex;
      gap: var(--gap);
      justify-content: center;
    }

    .tile {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      background: #0a0f12;
      border: 1px solid rgba(124,249,255,0.22);
      box-shadow:
        0 0 0 1px rgba(124,249,255,0.22) inset,
        0 8px 30px rgba(0,229,255,0.12),
        0 0 18px rgba(0,229,255,0.18);
      isolation: isolate;
    }
    .tile img {
      display: block;
      width: 100%;
      height: auto;
    }
    .tile::after {
      content: "";
      position: absolute;
      inset: -120% -120%;
      background: conic-gradient(from 0deg, rgba(124,249,255,0), rgba(124,249,255,0.15), rgba(124,249,255,0));
      animation: sweep 8s linear infinite;
      mix-blend-mode: overlay;
      pointer-events: none;
    }
    @keyframes sweep { to { transform: rotate(360deg); } }

    .tile.reveal {
      opacity: 0;
      transform: translateY(24px) scale(0.98);
      animation: popin 700ms ease forwards;
    }
    @keyframes popin { to { opacity: 1; transform: translateY(0) scale(1); } }
  </style>
</head>
<body>
  <div class="bg-tech"></div>
  <div class="scanlines"></div>
  <div class="stage" id="stage"></div>

  <script>
    const CONFIG = {
      apiKey: "4855498d62dbadaf2bd11df6fcdb9f08",
      username: "sulamitachurchpdx",
      targetRowHeight: 320,
      gap: 16,
      slideDurationMs: 12000,
      refreshMs: 300000,
      tags: "",
      shuffle: false,
    };

    const daySec = 24 * 60 * 60;
    const sevenDaysAgo = () => Math.floor(Date.now() / 1000) - 7 * daySec;

    const stage = document.getElementById('stage');

    let slides = [];
    let slideIndex = 0;
    let slideTimer = null;
    let refreshTimer = null;

    async function flickrFindNSID(apiKey, username) {
      const url = new URL('https://www.flickr.com/services/rest/');
      url.searchParams.set('method', 'flickr.people.findByUsername');
      url.searchParams.set('api_key', apiKey);
      url.searchParams.set('username', username);
      url.searchParams.set('format', 'json');
      url.searchParams.set('nojsoncallback', '1');
      const r = await fetch(url);
      const data = await r.json();
      return data.user.nsid;
    }

    async function flickrFetchRecent(apiKey, userId, tags) {
      const url = new URL('https://www.flickr.com/services/rest/');
      url.searchParams.set('method', 'flickr.photos.search');
      url.searchParams.set('api_key', apiKey);
      url.searchParams.set('user_id', userId);
      url.searchParams.set('min_upload_date', String(sevenDaysAgo()));
      url.searchParams.set('extras', 'url_m,url_l,url_o,width_m,height_m,width_l,height_l,o_dims,date_upload');
      url.searchParams.set('per_page', '250');
      url.searchParams.set('page', '1');
      url.searchParams.set('format', 'json');
      url.searchParams.set('nojsoncallback', '1');
      if (tags) url.searchParams.set('tags', tags);
      const r = await fetch(url);
      const data = await r.json();
      return data.photos.photo;
    }

    function bestImage(p) {
      let url = p.url_l || p.url_m || p.url_o || null;
      let w = p.width_l || p.width_m || p.width_o || null;
      let h = p.height_l || p.height_m || p.height_o || null;
      return url ? { url, w: Number(w), h: Number(h), title: p.title || '' } : null;
    }

    function buildJustifiedRows(items, containerWidth, targetRowHeight, gap, maxScaleUp=1.0) {
      const rows = [];
      let row = [];
      let rowAspectSum = 0;
      for (const it of items) {
        const ar = it.w && it.h ? it.w / it.h : 1.5;
        row.push({...it, ar});
        rowAspectSum += ar;
        const gaps = gap * (row.length - 1);
        const rowWidthAtTarget = rowAspectSum * targetRowHeight + gaps;
        if (rowWidthAtTarget >= containerWidth || row.length >= 6) {
          let rowH = (containerWidth - gaps) / rowAspectSum;
          rowH = Math.min(rowH, targetRowHeight);
          rows.push({h: Math.max(80, rowH), items: row});
          row = [];
          rowAspectSum = 0;
        }
      }
      if (row.length) {
        rows.push({h: Math.min(targetRowHeight, Math.max(80, (containerWidth - gap * (row.length - 1)) / (rowAspectSum || 1))), items: row});
      }
      return rows;
    }

    function paginateRowsToSlides(rows, containerHeight, gap) {
      const slides = [];
      let current = [];
      let used = 0;
      for (const r of rows) {
        const rowHeightWithGap = (current.length ? gap : 0) + r.h;
        if (used + rowHeightWithGap > containerHeight && current.length) {
          slides.push(current);
          current = [r];
          used = r.h;
        } else {
          current.push(r);
          used += rowHeightWithGap;
        }
      }
      if (current.length) slides.push(current);
      return slides;
    }

    function renderSlides(slides) {
      stage.innerHTML = '';
      const gap = CONFIG.gap;
      slides.forEach((rows) => {
        const slide = document.createElement('div');
        slide.className = 'slide';
        slide.style.setProperty('--gap', gap + 'px');
        rows.forEach((r, rowIdx) => {
          const rowEl = document.createElement('div');
          rowEl.className = 'row';
          rowEl.style.marginTop = rowIdx === 0 ? '0' : gap + 'px';
          r.items.forEach((it, j) => {
            const tile = document.createElement('div');
            tile.className = 'tile reveal';
            tile.style.height = r.h + 'px';
            const width = it.ar * r.h;
            tile.style.width = width + 'px';
            tile.style.animationDelay = (j * 90) + 'ms';
            const img = document.createElement('img');
            img.src = it.url;
            img.alt = it.title || 'Flickr photo';
            tile.appendChild(img);
            rowEl.appendChild(tile);
          });
          slide.appendChild(rowEl);
        });
        stage.appendChild(slide);
      });
    }

    function showSlide(i) {
      const all = Array.from(stage.children);
      all.forEach((el, idx) => {
        el.classList.toggle('active', idx === i);
      });
    }

    async function loadAndRender() {
      const userId = await flickrFindNSID(CONFIG.apiKey, CONFIG.username);
      let photos = await flickrFetchRecent(CONFIG.apiKey, userId, CONFIG.tags);
      photos.sort((a,b) => Number(b.dateupload || 0) - Number(a.dateupload || 0));
      photos = photos.map(bestImage).filter(Boolean);

      const containerWidth = stage.clientWidth - 48;
      const containerHeight = stage.clientHeight - 48;
      const rows = buildJustifiedRows(photos, containerWidth, CONFIG.targetRowHeight, CONFIG.gap, 1.0);
      const slidesRows = paginateRowsToSlides(rows, containerHeight, CONFIG.gap);

      slides = slidesRows;
      renderSlides(slides);
      slideIndex = 0;
      showSlide(slideIndex);

      if (slideTimer) clearInterval(slideTimer);
      slideTimer = setInterval(() => {
        slideIndex = (slideIndex + 1) % slides.length;
        showSlide(slideIndex);
      }, CONFIG.slideDurationMs);

      if (refreshTimer) clearInterval(refreshTimer);
      refreshTimer = setInterval(() => loadAndRender().catch(console.error), CONFIG.refreshMs);
    }

    window.addEventListener('resize', () => {
      if (!stage.children.length) return;
      loadAndRender().catch(console.error);
    });

    loadAndRender().catch(console.error);
  </script>
</body>
</html>
